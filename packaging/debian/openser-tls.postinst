#! /bin/sh
#
# $Id$

PKG=openser-tls
DEFAULTS=/etc/default/openser
HOMEDIR=/var/run/openser

set -e

# The loading of the confmodule is needed for debconf to work. don't remove
. /usr/share/debconf/confmodule

# summary of how this script can be called:
#        * <postinst> `configure' <most-recently-configured-version>
#        * <old-postinst> `abort-upgrade' <new version>
#        * <conflictor's-postinst> `abort-remove' `in-favour' <package>
#          <new-version>
#        * <deconfigured's-postinst> `abort-deconfigure' `in-favour'
#          <failed-install-package> <version> `removing'
#          <conflicting-package> <version>
# for details, see http://www.debian.org/doc/debian-policy/ or
# the debian-policy package
#
# quoting from the policy:
#     Any necessary prompting should almost always be confined to the
#     post-installation script, and should be protected with a conditional
#     so that unnecessary prompting doesn't happen if a package's
#     installation fails and the `postinst' is called with `abort-upgrade',
#     `abort-remove' or `abort-deconfigure'.

case "$1" in
    configure)
        adduser --quiet --system --group --disabled-password \
                --shell /bin/false --gecos "Open SIP Express Router" \
                --home $HOMEDIR openser || true

        ;;

    abort-upgrade|abort-remove|abort-deconfigure)

        ;;

    *)
        echo "postinst called with unknown argument \`$1'" >&2
        exit 1
        ;;
esac


# deb_helper is not used here to avoid automatically starting openser after
# the installation. Instead we will use the user supplied answer about
# starting on boot


# Read in settings that are not handled by debconf, but may have been modified
# by the user. We want to preserve them.
USER=openser
GROUP=openser
if [ -f $DEFAULTS ]; then
    . $DEFAULTS || true
    [ -z "$USER" ]  && USER=openser
    [ -z "$GROUP" ] && GROUP=openser
fi

RET=
db_get openser/start_on_boot || true
if [ "$RET" = true ]; then
    START_ON_BOOT=yes
else
    START_ON_BOOT=no
fi

RET=
db_get openser/master_node || true
if [ "$RET" = true ]; then
    MASTER_NODE=yes
else
    MASTER_NODE=no
fi

RET=
db_get openser/memory_ammount || true
MEMORY=$((`echo $RET | sed -e 's/[^0-9]//g'`))
[ $MEMORY -le 0 ] && MEMORY=32

RET=
db_get openser/dump_core || true
if [ "$RET" = true ]; then
    DUMP_CORE=yes
else
    DUMP_CORE=no
fi

cat >$DEFAULTS <<EOF
#
# OpenSER startup options
#
# This file was generated by debconf when $PKG was installed.
# To modify the options run 'dpkg-reconfigure $PKG'
# Options can also be manually edited and they will be preserved when
# dpkg-reconfigure is run next time, but in this case you have to restart
# the server yourself. dpkg-reconfigure automatically takes care of stopping
# and starting the server as required.
# Some options in this file (USER and GROUP) are not handled by debconf and
# they can only be edited manually.
#

# User to run as (not handled by debconf).
USER=$USER

# Group to run as (not handled by debconf).
GROUP=$GROUP

# Ammount of memory to allocate for the running OpenSER server (in Mb)
MEMORY=$MEMORY

# Enable the server to leave a core file when it crashes.
# Set this to 'yes' to enable OpenSER to leave a core file when it crashes
# or 'no' to disable this feature. This option is case sensitive and only
# accepts 'yes' and 'no' and only in lowercase letters.
#
# Please note that when this is enabled, the USER and GROUP options above
# will be ignored and the root user/group will be used instead. This is
# because only then OpenSER will be able to leave a core file.
# If someone knows how this can be made to work even when the server runs as
# user openser, please let us know. Tests show that if only as much as the
# group is set to openser, while the user is root for the running server,
# it will still refuse to write the core file.
DUMP_CORE=$DUMP_CORE

EOF


# Create a radius sequence file to be used by the radius client if
# radius accounting is enabled. This is needed to avoid any issue
# with the file not being writable if openser first starts as user
# root because DUMP_CORE is enabled and creates this file as user
# root and then later it switches back to user openser and cannot
# write to the file. If the file exists before openser starts, it
# won't change it's ownership and will be writable for both root
# and openser, no matter what options are chosen at install time
RADIUS_SEQ_FILE=/var/run/openser/openser_radius.seq
if [ -d /var/run/openser ]; then
   chown ${USER}.${GROUP} $HOMEDIR
   if [ ! -f $RADIUS_SEQ_FILE ]; then
      touch $RADIUS_SEQ_FILE
   fi
   chown ${USER}.${GROUP} $RADIUS_SEQ_FILE
   chmod 660 $RADIUS_SEQ_FILE
fi


if [ $START_ON_BOOT = "yes" ]; then
    if [ -x "/etc/init.d/openser" ]; then
        update-rc.d openser defaults 23 >/dev/null
        if [ -x "`which invoke-rc.d 2>/dev/null`" ]; then
            invoke-rc.d openser start || exit 0
        else
            /etc/init.d/openser start || exit 0
        fi
    fi
else
    update-rc.d -f openser remove >/dev/null
    if [ $MASTER_NODE = "yes" -a -x "/etc/init.d/openser" ]; then
        if [ -x "`which invoke-rc.d 2>/dev/null`" ]; then
            invoke-rc.d openser start || exit 0
        else
            /etc/init.d/openser start || exit 0
        fi
    fi
fi

db_stop

exit 0


