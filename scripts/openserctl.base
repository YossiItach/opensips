#
# $Id$
#
# sc: openser control; tool for maintaining openser
#
#===================================================================

##### ----------------------------------------------- #####
### path to useful tools
locate_tool() {
	TOOLPATH=""
	while [ -n "$1" ]
	do
		if [ -x /usr/bin/which ] ; then
			TOOLPATH=`which $1`
			if [ -n "$TOOLPATH" ]; then
				return
			fi
		fi
		# look in common locations
		if [ -x "/usr/bin/$1" ] ; then
			TOOLPATH="/usr/bin/$1"
			return
		fi
		if [ -x "/bin/$1" ] ; then
			TOOLPATH="/bin/$1"
			return
		fi
		if [ -x "/usr/local/bin/$1" ] ; then
			TOOLPATH="/usr/local/bin/$1"
			return
		fi
		shift
	done
	return
}

if [ -z "$EGREP" ] ; then
	locate_tool egrep
	if [ -z "$TOOLPATH" ] ; then
		# now error, but we can look for alternative names if it is the case
		echo "error: 'egrep' tool not found: set EGREP variable to correct tool path"
		exit
	fi
	EGREP="$TOOLPATH"
fi
if [ -z "$AWK" ] ; then
	locate_tool awk
	if [ -z "$TOOLPATH" ] ; then
		# now error, but we can look for alternative names if it is the case
		echo "error: 'awk' tool not found: set AWK variable to correct tool path"
		exit
	fi
	AWK="$TOOLPATH"
fi
if [ -z "$MD5" ]; then
	locate_tool md5sum md5
	if [ -z "$TOOLPATH" ] ; then
		# now error, but we can look for alternative names if it is the case
		echo "error: 'md5sum' or 'md5' tool not found: set MD5 variable to correct tool path"
		exit
	fi
	MD5="$TOOLPATH"
fi
if [ -z "$LAST_LINE" ] ; then
	locate_tool tail
	if [ -z "$TOOLPATH" ] ; then
		# now error, but we can look for alternative names if it is the case
		echo "error: 'TAIL' tool not found: set TAIL variable to correct tool path"
		exit
	fi
	LAST_LINE="$TOOLPATH -n 1"
fi
if [ -z "$EXPR" ] ; then
	locate_tool expr
	if [ -z "$TOOLPATH" ] ; then
		# now error, but we can look for alternative names if it is the case
		echo "error: 'expr' tool not found: set EXPR variable to correct tool path"
		exit
	fi
	EXPR="$TOOLPATH"
fi

##### ------------------------------------------------ #####
### configuration for starting/stopping openser
if [ -z "$PID_FILE" ] ; then
	PID_FILE=/var/run/openser.pid
fi
if [ -z "$SYSLOG" ] ; then
	SYSLOG=1 # 0=output to console, 1=output to syslog
fi
if [ -z "$STARTOPTIONS" ] ; then
	STARTOPTIONS= # for example -dddd
fi
if [ -z "$DIR" ] ; then
	DIR=`dirname $0`
fi
if [ -z "$OSERBIN" ] ; then
	OSERBIN=$DIR/openser
fi

##### ------------------------------------------------ #####
### aliases configuration
#
ENABLE_ALIASES=0
if [ "$ALIASES_TYPE" = "UL" ] ; then
	ENABLE_ALIASES=1
else
	if [ "$ALIASES_TYPE" = "DB" ] ; then
		ENABLE_ALIASES=2
	fi
fi


##### ----------------------------------------------- #####
#### Defined values
ALL_METHODS=4294967295
USERNAME_RE="[-a-zA-Z0-9&=\+\$,;\?/_\.\!~\*'\(\)]+"

##### ----------------------------------------------- #####
#### Common functions

usage_base() {
	echo
	mecho " -- command 'start|stop|restart'"
	echo
cat <<EOF
 restart ............................ restart OpenSER
 start .............................. start OpenSER
 stop ............................... stop OpenSER
EOF
}
USAGE_FUNCTIONS="$USAGE_FUNCTIONS usage_base"

mdbg() {
	if [ "0$VERBOSE" -ne 0 ] ; then
		if [ -t 1 -a -z "$NOHLPRINT" ] ; then
			echo -e "\033[1m$1\033[0m"
		else
			echo "$1"
		fi
	fi
}

mwarn() {
	if [ -t 1 -a -z "$NOHLPRINT" ] ; then
		echo -e '\E[37;32m'"\033[1mWARNING: $1\033[0m"
	else
		echo "** WARNING: $1"
	fi
}

minfo() {
	if [ -t 1 -a -z "$NOHLPRINT" ] ; then
		echo -e '\E[37;33m'"\033[1mINFO: $1\033[0m"
	else
		echo "** INFO: $1"
	fi
}

mecho() {
	if [ -t 1 -a -z "$NOHLPRINT" ] ; then
		echo -e "\033[1m$1\033[0m"
	else
		echo "$1"
	fi
}

merr() {
	if [ -t 1 -a -z "$NOHLPRINT" ] ; then
		echo -e '\E[37;31m'"\033[1mERROR: $1\033[0m"
	else
		echo "** ERROR: $1"
	fi
}


# determine host name, typically for use in printing UAC
# messages; we use today a simplistic but portable uname -n way --
# no domain name is displayed ; fifo_uac expands !! to host
# address only for optional header fields; uname output without
# domain is sufficient for informational header fields such as
# From
#
get_my_host() {
	if [ -z "$SIP_DOMAIN" ]; then
		uname -n
	else
		echo "$SIP_DOMAIN"
	fi
}

# calculate name and domain of current user
set_user() {

	OSERUSER=`echo $1|$AWK -F@ '{print $1}'`
	OSERDOMAIN=`echo $1|$AWK -F@ '{print $2}'`

	if [ -z "$OSERDOMAIN" ] ; then
		OSERDOMAIN="$SIP_DOMAIN"
	fi

	if [ -z "$OSERDOMAIN" ] ; then
		merr "domain unknown: use usernames with domain or set default domain \
in SIP_DOMAIN"
		exit 1
	fi
}

# check the parameter if it is a valid address of record (user@domain)
check_aor() {
	echo "$1" | $EGREP "^$USERNAME_RE@.*\..*" >/dev/null
	if [ $? -ne 0 ] ; then 
		echo "error: invalid AoR: $1" > /dev/stderr
		exit 1
	fi
}

# check the parameter if it is a valid address of record (user@domain)
is_aor() {
	echo "$1" | $EGREP "^$USERNAME_RE@.*\..*" >/dev/null
	if [ $? -ne 0 ] ; then 
		false
	else
		true
	fi
}

# check the parameter if it is a valid SIP address of record (sip:user@domain)
check_sipaor() {
	echo "$1" | $EGREP "^sip(s)?:$USERNAME_RE@.*\..*" >/dev/null
	if [ $? -ne 0 ] ; then 
		echo "error: invalid SIP AoR: $1" > /dev/stderr
		exit 1
	fi
}

# check the parameter if it is a valid SIP URI
# quite simplified now -- it captures just very basic
# errors
check_uri() {
	echo "$1" | $EGREP "^sip(s)?:($USERNAME_RE@)?.*\..*"  > /dev/null
	if [ $? -ne 0 ] ; then 
		echo "error: invalid SIP URI: $1" > /dev/stderr
		exit 1
	fi
}

print_status() {
	echo $1 | grep "^[1-6][0-9][0-9]" > /dev/null
	if [ "$?" -eq 0 ] ; then 
		echo $1
	else
		echo "200 OK"
	fi
}

# process output from FIFO/Unixsock server; if everything is ok
# skip the first "ok" line and proceed to returned 
# parameters
filter_fl()
{
#	tail +2
	
	$AWK 'BEGIN {line=0;IGNORECASE=1;}
		{line++}
		line==1 && /^200 ok/ { next }
		/^$/ { next }
		{ print }'
}

# params: user, realm, password
# output: HA1
_gen_ha1()
{
	HA1=`echo -n "$1:$2:$3" | $MD5 | $AWK '{ print $1 }'`
	if [ $? -ne 0 ] ; then
		echo "HA1 calculation failed"
		exit 1
	fi
}

# params: user, realm, password
# output: HA1B
_gen_ha1b()
{
	HA1B=`echo -n "$1@$2:$2:$3" | $MD5 | $AWK '{ print $1 }'`
	if [ $? -ne 0 ] ; then
		echo "HA1B calculation failed"
		exit 1
	fi
}

# params: user, realm, password
# output: PHPLIB_ID
_gen_phplib_id()
{
	NOW=`date`;
	PHPLIB_ID=`echo -n "$1$2:$3:$NOW" | $MD5 | $AWK '{ print $1 }'`
}

# params: user, password
# output: HA1, HA1B
credentials()
{
	set_user $1
	_gen_ha1 "$OSERUSER" "$OSERDOMAIN" "$2"
	_gen_ha1b "$OSERUSER" "$OSERDOMAIN" "$2"
}


