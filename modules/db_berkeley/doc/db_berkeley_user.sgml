<!-- Module User's Guide -->

<chapter>
	<chapterinfo>
	<revhistory>
		<revision>
		<revnumber>$Revision: 846 $</revnumber>
		<date>$Date: 2006-05-22 09:15:40 -0500 (Mon, 22 May 2006) $</date>
		</revision>
	</revhistory>
	</chapterinfo>
	<title>User's Guide</title>
	
	<section>
	<title>Overview</title>
	<para>
		This is a module which integrates the Berkeley DB into OpenSER.
		It implements the DB API defined in OpenSER.
	</para>
	</section>

	<section>
	<title>Dependencies</title>
	<section>
		<title>&ser; Modules</title>
		<para>
		The following modules must be loaded before this module:
			<itemizedlist>
			<listitem>
			<para>
				<emphasis>No dependencies on other &ser; modules</emphasis>.
			</para>
			</listitem>
			</itemizedlist>
		</para>
	</section>
	
	<section>
		<title>External Libraries or Applications</title>
		<para>
		The following libraries or applications must be installed before running
		&ser; with this module loaded:
			<itemizedlist>
			<listitem>
			<para>
				<emphasis>Berkeley Berkeley DB 4.5</emphasis> - an embedded database.
			</para>
			</listitem>
			</itemizedlist>
		</para>
	</section>
	</section>
	<section>
	<title>Exported Parameters</title>
	<section>
		<title><varname>auto_reload</varname> (integer)</title>
		<para>
		The auto-reload will close and reopen a Berkeley DB when the
		files inode has changed. The operation occurs only duing a query. 
		Other operations such as insert or delete, do not invoke auto_reload.
		</para>
		<para>
		<emphasis>
			Default value is 0 (1 - on / 0 - off).
		</emphasis>
		</para>
		<example>
		<title>Set <varname>auto_reload</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("db_berkeley", "auto_reload", 1)
...
		</programlisting>
		</example>
	</section>
	
	<section>
		<title><varname>log_enable</varname> (integer)</title>
		<para>
		The log_enable boolean controls when to create journal files.
		The following operations can be journaled: 
		INSERT, UPDATE, DELETE. Other operations such as SELECT, do not. 
		This journaling are required if you need to recover from a corrupt 
		DB file. That is, bdb_recover requires these to rebuild 
		the db file. If you find this log feature useful, you may 
		also be interested in the METADATA_LOGFLAGS bitfield that each 
		table has. It will allow you to control which operations to 
		journal, and the destination (like syslog, stdout, local-file). 
		Refer to sclib_log()  and documentation on METADATA.
		</para>
		<para>
		<emphasis>
			Default value is 0 (1 - on / 0 - off).
		</emphasis>
		</para>
		<example>
		<title>Set <varname>log_enable</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("db_berkeley", "log_enable", 1)
...
		</programlisting>
		</example>
	</section>
	
	<section>
		<title><varname>journal_roll_interval</varname> (integer seconds)</title>
		<para>
		The journal_roll_interval will close and open a new log file. 
		The roll operation occurs only at the end of writing a log, 
		so it is not guaranteed to to roll 'on time'.
		</para>
		<para>
		<emphasis>
			Default value is 0 (off).
		</emphasis>
		</para>
		<example>
		<title>Set <varname>journal_roll_interval</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("db_berkeley", "journal_roll_interval", 3600)
...
		</programlisting>
		</example>
	</section>
	
	</section>
	
	<section>
	<title>Exported Functions</title>
		<para>
		No function exported to be used from configuration file.
		</para>
	</section>
	
	<section>
	<title>Installation and Running</title>
		<para>
		First download, compile and install the Berkeley DB. This is 
		outside the scope of this document. Documentation for this 
		procedure is available on the Internet.
		</para>
		
		<para>
		Next, we setup to compile OpenSER with the db_berkeley module. 
		In the directory /modules/db_berkeley , modify the Makefile to point 
		to your distribution of Berkeley DB.
		</para>
		
		<para>
		You may also define 'SC_EXTRA_DEBUG' to compile in extra debug logs. 
		However, it is not a recommended deployment to production servers.
		Because the module dependes on an external library, the db_berkeley module is not
		compiled and installed by default. You can use one of the next options.
		</para>
		
		<itemizedlist>
			<listitem>
			<para>
			edit the "Makefile" and remove "db_berkeley" from "excluded_modules"
			list. Then follow the standard procedure to install &ser;:
			"make all; make install".
			</para>
			</listitem>
			<listitem>
			<para>
			from command line use: 'make all include_modules="db_berkeley";
			make install include_modules="db_berkeley"'.
			</para>
			</listitem>
		</itemizedlist>
		
		<para>
		Installation of OpenSER is performed by simply running make install
		as root user of the main directory. This will install the binaries in /usr/local/sbin/.
		If this was successful, the scripts/db_berkeley.sh file should now 
		be installed as /usr/local/sbin/openser_db_berkeley.sh 
		</para>
		
		<para>
		Once you decide where you want to install the Berkeley DB files, 
		for instance '/var/db_berkeley/bdb', we must initially create 
		the files there. OpenSER will not startup without these DB files 
		already existing. Here are a couple of ways to do this:
		</para>
		
		<example>
		<title>1</title>
		<programlisting format="linespecific">
export DB_HOME=/var/db_berkeley/bdb ; /usr/local/sbin/openser_db_berkeley.sh create
		</programlisting>
		</example>

		<para>
		This way, any later operations with openser_db_berkeley.sh will not require 
		you to provide the path to your DB files.
		Alternately, you can specify them on the command line like this:
		</para>
		
		<example>
		<title>2</title>
		<programlisting format="linespecific">
/usr/local/sbin/openser_db_berkeley.sh create /var/db_berkeley/bdb
		</programlisting>
		</example>
		
		<para>
		After this creation step, the DB files are now seeded with the 
		necessary meta-data for OpenSER to startup. For a description of 
		the meta-data refer to the section about db_berkeley.sh operations.
		Modify the OpenSER configuration file to use db_berkeley. The 
		database URL for modules must be the path to the directory where 
		the Berkeley DB table-files are located, prefixed by "db_berkeley://", 
		e.g., "db_berkeley:///var/db_berkeley/bdb". If you require the DB file 
		to automatically reload be sure to include the modparam line for that.
		</para>
		
		<para>
		A couple other things to consider are the 'db_mode' and the 'use_domain' 
		modparams, as they will impact things as well. The best description of 
		these parameters are found in usrloc documentation.
		</para>
		
		<para>
		The '|' pipe character is used as a record delimiter within this 
		Berkeley DB implementation and must not be present in any DB field.
		</para>
	</section>
	
	<section>
	<title>Database Schema and Metadata</title>
	
	<para>
	Each Berkeley DB is must be manually, initially created via the 
	openser_db_berkeley.sh maintenance utility. This section provides some 
	details as to the content and format of the DB file upon creation.
	</para>

	<para>
	Since the Berkeley DB stores key value pairs, the database is seeded 
	with a few meta-data rows . The keys to these rows must begin with 'METADATA'. 
	Here is an example of table meta-data, taken from the table 'version'.
	</para>

	<example>
	<title>3</title>
	<programlisting format="linespecific">
METADATA_COLUMNS
table_name(str) table_version(int)
METADATA_KEY
0
	</programlisting>
	</example>

	<para>
	In the above example, the row METADATA_COLUMNS defines the column names 
	and type, and the row METADATA_KEY defines which column(s) form the key. 
	Here the value of 0 indicates that column 0 is the key(ie table_name). 
	With respect to column types, the db_berkeley modules only has the following 
	types: string, str, int, double, and datetime. The default type is string, 
	and is used when one of the others is not specified. The columns of the 
	meta-data are delimited by whitespace.
	</para>

	<para>
	The actual column data is stored as a string value, and delimited by 
	the '|' pipe character. Since the code tokenizes on this delimiter, 
	it is important that this character not appear in any valid data field. 
	The following is the output of the 'db_berkeley.sh dump version' command. 
	It shows contents of table 'version' in plain text.
	</para>
	
	<example>
	<title>contents of version table</title>
	<programlisting format="linespecific">
VERSION=3
format=print
type=hash
h_nelem=21
db_pagesize=4096
HEADER=END
 METADATA_READONLY
 1
 address|
 address|3
 aliases|
 aliases|1004
 dbaliases|
 dbaliases|1
 domain|
 domain|1
 gw_grp|
 gw_grp|1
 gw|
 gw|4
 speed_dial|
 speed_dial|2
 subscriber|
 subscriber|6
 uri|
 uri|1
 METADATA_COLUMNS
 table_name(str) table_version(int)
 METADATA_KEY
 0
 acc|
 acc|4
 grp|
 grp|2
 lcr|
 lcr|2
 location|
 location|1004
 missed_calls|
 missed_calls|3
 re_grp|
 re_grp|1
 silo|
 silo|5
 trusted|
 trusted|4
 usr_preferences|
 usr_preferences|2
DATA=END
	</programlisting>
	</example>
	</section>
	
	<section>
	<title>METADATA_COLUMNS (required)</title>
	<para>
	The METADATA_COLUMNS row contains the column names and types. 
	Each is space delimited. Here is an example of the data taken from table subscriber :
	</para>
	
	<example>
	<title>METADATA_COLUMNS</title>
	<programlisting>
METADATA_COLUMNS
username(str) domain(str) password(str) ha1(str) ha1b(str) first_name(str) last_name(str) email_address(str) datetime_created(datetime) timezone(str) rpid(str)
 	</programlisting>
	</example>
	
	<para>
	Related (hardcoded) limitations:
	<itemizedlist>
		<listitem>
			<para>maximum of 32 columns per table.</para>
		</listitem>
		
		<listitem>
			<para>maximum tablename size is 64.</para>
		</listitem>
		
		<listitem>
			<para>maximum data length is 2048</para>
		</listitem>
	</itemizedlist>
	</para>
	
	<para>
	Currently supporting these five types: str, datetime, int, double, string.
	</para>
	
</section>

	<section>
	<title>METADATA_KEYS (required)</title>
	<para>
	The METADATA_KEYS row indicates the indexes of the key columns, 
	with respect to the order specified in METADATA_COLUMNS. 
	Here is an example taken from table subscriber that brings up a good point:
	</para>
	
	<example>
	<title>METADATA_KEYS</title>
	<programlisting>
 METADATA_KEY
 0 1
 	</programlisting>
	</example>

 	<para>
	The point is that both the username and domain name are require 
	as the key to this record. Thus, usrloc modparam 
	use_domain = 1 must be set for this to work.
	</para>
	
	</section>

	<section>
	<title>METADATA_READONLY (optional)</title>
	<para>
	The METADATA_READONLY row contains a boolean 0 or 1. 
	By default, its value is 0. On startup the DB will 
	open initially as read-write (loads metadata) and then if this 
	is set=1, it will close and reopen as read only (ro). 
	I found this useful because readonly has impacts on the 
	internal db locking etc.
	</para>
	
	</section>

	<section>
	<title>METADATA_LOGFLAGS (optional)</title>
	<para>
	The METADATA_LOGFLAGS row contains a bitfield that customizes the 
	journaling on a per table basis. If not present the default value 
	is taken as 0. Here are the masks so far (taken from sc_lib.h):
	</para>
	
	<example>
	<title>METADATA_LOGFLAGS</title>
	<programlisting>
#define JLOG_NONE 0
#define JLOG_INSERT 1
#define JLOG_DELETE 2
#define JLOG_UPDATE 4
#define JLOG_STDOUT 8
#define JLOG_SYSLOG 16
	</programlisting>
	</example>
	
	<para>
	This means that if you want to journal INSERTS to local file and syslog the value 
	should be set to 1+16=17. Or if you do not want to journal at all, set this to 0.
	</para>
	
	</section>
	
	<section>
	<title>Maintaince Shell Script : db_berkeley.sh </title>
	<para>
	The db_berkeley.sh is located in the [openser_root_dir]/scripts directory. 
	The script will print help when invoked without parameters on the 
	command line. The following is the help text.
	</para>
	
	<para>
	Script for maintaining OpenSER Berkeley DB tables
	<example>
	<title>db_berkeley.sh usageS</title>
	<programlisting>
usage: db_berkeley.sh create   [DB_HOME] (creates the db with files with metadata)
       db_berkeley.sh presence [DB_HOME] (adds the presence related tables)
       db_berkeley.sh extra    [DB_HOME] (adds the extra tables - imc,cpl,siptrace,domainpolicy)
       db_berkeley.sh drop     [DB_HOME] (deletes db files in DB_HOME)
       db_berkeley.sh reinit   [DB_HOME] (drop and create tables in one step)
       db_berkeley.sh list     [DB_HOME] (lists the underlying db files on the FS)
       db_berkeley.sh backup   [DB_HOME] (tars current database)
       db_berkeley.sh restore   bu [DB_HOME] (untar bu into DB_HOME)
       db_berkeley.sh dump      db [DB_HOME] (db_dump the underlying db file to STDOUT)
       db_berkeley.sh swap      db [DB_HOME] (installs db.new by db -> db.old; db.new -> db)
       db_berkeley.sh newappend db datafile [DB_HOME] (appends data to a new instance of db; output DB_HOME/db.new)
	</programlisting>
	</example>
	</para>
	</section>
	
	<section>
	<title>DB Recovery : bdb_recover</title>
	<para>
	The db_berkeley module uses the Concurrent Data Store (CDS) architecture. 
	As such, no transaction or journaling is provided by the DB natively. 
	The application bdb_recover is specifically written to recover data from 
	journal files that OpenSER creates.  
	The bdb_recover application requires an additional text file that contains 
	the table schema.
	</para>
	
	<para>
	The schema is loaded with the '-s' option and is required for all operations.
	</para>
	
	<para>
	The '-h' home option is the DB_HOME path. Unlike the Berkeley utilities, 
	this application does not look for the DB_HOME environment variable, 
	so you have to specify it. If not specified, it will assume the current 
	working directory. The last argument is the operation. 
	There are fundamentally only two operations- create and recover. 
	</para>
	
	<para>
	The following illustrates the four operations available to the administrator.
	<example>
	<title>bdb_recover usage</title>
	<programlisting>
usage: ./bdb_recover -s schemafile [-h home] [-c tablename]
	This will create a brand new DB file with metadata.

usage: ./bdb_recover -s schemafile [-h home] [-C all]
	This will create all the core tables, each with metadata.

usage: ./bdb_recover -s schemafile [-h home] [-r journal-file]
	This will rebuild a DB and populate it with operation from journal-file. 
	The table name is embedded in the journal-file name by convention.

usage: ./bdb_recover -s schemafile [-h home] [-R lastN]
	This will iterate over all core tables enumerated. If journal files exist in 'home', 
	a new DB file will be created and populated with the data found in the last N files. 
	The files are 'replayed' in chronological order (oldest to newest). This 
	allows the administrator to rebuild the db with a subset of all possible 
	operations if needed. For example, you may only be interested in 
	the last hours data in table location.
	</programlisting>
	</example>
	</para>
	
	<para>
	It is important to note that the corrupted DB file must be moved 
	out of the way before bdb_recover is executed.
	</para>
	
	</section>
</chapter>

<!-- Keep this element at the end of the file
Local Variables:
sgml-parent-document: "db_berkeley.sgml" "Book" "chapter")
End:
-->
